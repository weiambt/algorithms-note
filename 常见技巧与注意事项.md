# 技巧与注意事项

## 数据范围

- 数组长度n的范围决定：arr[N]

- 数组元素的最大范围决定：用int还是long（一般是int），前缀和数组一般会爆Int，所以注意题意是否能将数组取模，否则就用long（即使用long都有危险）

- 数据元素的范围如果是可以负数，那么就不能用双指针滑动窗口（因为双指针的本质是单调性，当i向后移动的时候，如果元素是正数，j也是向后移动。如果是负数，就不满足这一点）

- long ans=0;答案用long存储会多过很多数据

- log(1000)=10,log(2000)=11

- 求方案数用long存储，很容易爆int

- 二维int数组最大开到2*10^7，N一定要控制在4000以内，128MB

- 做题记得看数据范围，如果是10^9,10^18,10^5，有可能是公式解。

  如果是10^3,那么很可能是DP
  
- 题目中求的是最大值时，数据范围可能是负数，最大值变量mx一定要初始化成-INF，不要初始化成0。同理，最小值要初始化成INF

- 程序里的乘除法一定要特别注意，和逻辑上的乘除法不一样，向下取整不一样，乘法除法顺序导致结果不一样，比如：https://www.acwing.com/activity/content/code/add/8030/

- 元素都是正的，前缀和是递增的，对于区间求和的问题，就可以二分了；因为前缀和是单增的，也可以用双指针。

- 乘法除了注意顺序外，还需要注意爆int

- 前缀和容易爆int，最后用long存

- 数组下标越界：如果数组下标涉及到了减法，那么就特判一下是否大于0

- 在用快速幂的时候，注意取模，不是题目给了Mod就能取模的，比如：题目要对答案个数取模，在求快速幂的时候就不能取模

- 输入在超过1e6就要用快读，lqb中1e5的输入就最好用快读

- 输出println次数超过1e5就要用快写、print次数超过1e6就要用快写

- 蓝桥杯中最好每题都用快读快写，这样防止忘了

- 对拍很容易写错，很容易一直AC，所以一定要看实际的数据和结果

- 如果数组存答案的题目，数组大小最好是动态定义，a = new int[n]，由于不确定到底能不能开这个大小的数组，所以这样最稳妥

- 快速幂的所有变量都是long：a,b,mod,返回值，否则会WA

- 题目条件的理解：没有思路时，先想想不满足的情况，输出-1

- 输入用StreamTokenizer，比用Scanner快一倍

- 多组数据的输入，可以放在static中预处理执行

- 多组测试用例不一定是孤立的，有时不需要先预处理

  比如T= 1e5，我不需要预处理完所有情况（会超时），我只需要读1个处理一个，然后记忆化。

### 空间

128MB= 1e8 B

int占4字节，long占8字节

| 最大容量 | 字节数 | int数组 | long数组 |
| -------- | ------ | ------- | -------- |
| 128M     | 1e8 B  | 2e7个   | 1e7个    |
| 256M     |        |         |          |
| 512M     | 4e8 B  | 8e7     | 4e7      |

- 但是内存一般开一半，因为另外一半要留给运行（比如递归）
- 一般来说int数组就开成3e7最大

## 递归

### 后序+中序构建二叉树

```java
static int build(int il,int ir,int pl,int pr) {
    int root = postOrder[pr];
    int rootIdx = pos[root];//找到根节点在中序遍历序列中的位置。
    if(rootIdx-1>=il)
        l[root] = build(il, rootIdx-1, pl, pl+rootIdx-1-il);//后序左子树右端点x =  pl+rootIdx-1-il
    if(rootIdx+1<=ir)
        r[root] = build(rootIdx+1, ir, pl+rootIdx-il,pr-1);//后序右子树左端点：x+1
    return root;
}
```

https://www.acwing.com/activity/content/code/content/5622312/

## 二分

存在单调性即可二分

- nums[i]>0的前缀和是单调增的，可以二分
- 子区间的GCD是单调减的，可以二分





## 递推

**递推能降低时间复杂度**

### 子数组的最大公约数

 res = __gcd(res,nums[i])

- 例题

  lc2447. 最大公因数等于 K 的子数组数目

### 子数组的最大最小值



- 例题

  lc915. 分割数组（寻找子数组的最大最小值）



### 递推降低时间复杂度

这类题目很巧，循环的过程中，一边计数。当第i轮是，前面i-1轮计数的值为cnt，此时的cnt刚好可以作为ans在第i个位置的贡献。从而时间复杂度能降低一层。

[AcWing 3956. 截断数组](https://www.acwing.com/file_system/file/content/whole/index/content/8082442/)

## 前缀和

sum[i]=sum[i-1]+nums[i] (i一般从1开始)

也可以使用滚动数组

nums[i]+=nums[i-1]



## 不改变数组元素顺序的排序

### 顺序数组idx(下标)

可以操作下标进行排序

定义

vector< int > idx(n);

初始化

for(int i=0;i<n;i++) idx[i]=i;

排序

```
sort(idx.begin(),idx.end(),[&](int a,int b){
	nums[a]<nums[b];//升序，根据这个下标的值排序
})
```

此时，idx[i]=x， 表示nums中第i+1小的值是x。例如idx[0]=2,表示nums中最小的元素是2

### 元素的排名数组idx2（下标）

对上述的idx取反函数，得到idx2。

idx2[i]=x表示nums[i]在nums中的排名



例题：lc915. 分割数组（寻找子数组的最大最小值）



## 双指针

lc209长度最小的子数组(有思考量)



### 和不大于K的子数组个数问题

双指针，第十三届蓝桥杯 C++ B 组省赛 F 题——统计子矩阵 （AC）的来源

## 和为 K 的子数组问题

前缀和+哈希表解决

lc560

lc523

lc974

蓝桥杯真题（k倍区间）：https://www.dotcpp.com/oj/problem1882.html?sid=9373975&lang=3#editor

> 题解：https://leetcode.cn/problems/subarray-sum-equals-k/solutions/1956637/by-insomnia-5h-t3yu/



## 字符串消除问题（相同字母抵消）

> 对于一个字符串s，删除中间的相同连续字母对，最终得到的字符串中不能存在相同连续字母对。（如果删除某一对后，出现了新的相同连续字母对，则新的对也应当被删除。）
>
> 例子：输入：abcddcef；输出：abef

**解决思路**

使用栈去维护这个字符串

假设，栈中存放着的字符串已经合法（栈中不存在相同连续字母对），那么当下一个s[i]来了后，只需要和栈顶比一下是否相等即可，如果相等，那么出栈一次，否则进站。这个思路类似括号问题的思路（左括号只负责进站，右括号负责判断），对应于这个题，一个字母第k次出现，如果k是个奇数，那么就直接进栈，如果是个偶数，那么就判断。

> 例题：AcWing 4720. 字符串



## 找右边离他最远的比它小的数

> 问题描述：找到arr[i]最右边的那一个比它小的数：单调队列 + 二分 O（nlogn）

例题：AcWing 4721. 排队



